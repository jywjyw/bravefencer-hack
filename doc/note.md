======bug====
* 需要记忆卡存档： 村庄救火前,小字消除
决斗
s637省略号字幕时间不太对

救火：SC04/017/0.4
801887e0:52010801,OFFSET=602d8
801887fc:52010001,OFFSET=602f4
80188818:52011001,OFFSET=60310
u=0152&3f<<2=0x48
都改成40015001,抹掉三个文字




LIST.CD
包含其它所有CD的trim后的头信息(8字节的倍数)，游戏开始后加载进内存.

.CD的头信息
每个cdheader占1个sector, 前8个字节代表该包中有0x31个subcd,
接下来是每8个字节一组的子目录指针,指针的前4字节代表该subcd的起始位置位于第N个sector(每个sector 0x800字节,0xD代表子包位于0x6800处), 后4字节代表子包的大小


SUBCD的大小必须为0x800的倍数, 不够的话后补0, 
SUBCD可能的格式为:PAC链表/SQV/未知文件, 其中, PAC链表包含N个PAC

什么是PAC链表？例如有N张图片，首先在每个图片尾部补齐至0x800的倍数，再在每个图片头部加上0x800的PAC头,用来存放图片大小，图片类型等，即构成一个PAC链表。
PAC头的格式如下:
- 4字节: 魔数50414300, 即PAC的ASCII码
- 1字节: 文件类型 0~8,判断是否小于9
- 1字节: N个PAC链式存放在subcd文件中, 如果该PAC后面还有其它PAC, 则为0, 否则为1.
- 2字节: 0
- 4字节: ??
- 4字节: 文件长度,从PAC魔数的位置算起,共有多少字节,比如7c580000，pac内有效数据大小为0x587c-0x800=0x507c
标题和文件与扇区对齐，填充零

PAC类型:
0:图像(most of them are 32*32 image blocks. in 8bpp mode means 64*32, in 4bpp mode means 128*32)
1:图像/脚本
2:VAB文件头
3:VAB文件数据
4:压缩脚本
5:??
6:?? 数据=0x800,全部数据都在第1个0x800中
7:??
8:图像

SQV格式(midi):
- 4字节:魔数sqv
- 4字节:如果是，则包含MThd文件           相对于MThd文件的偏移量（将值加4）（如上所述，只有3个偏移量可用）
标题对齐到16个字节，用零填充
文件对齐到4个字节，用零填充

在MThd后面有一个0x7000的VAB文件

===============内存规划=======================
80010000~80073fff:SLPS_014.90
80074000~80078BD0:???
80078BD0~800793D0:临时存放待解压的脚本或上传到GPU的图像, 通常每次读取0x800字节,解压时一次存放78BD0~793D0共0x800字节
800B9480~??: SQV
800CDF58~80128504:第1脚本MAIN/010/1.1,常驻内存,起始位置指针似乎位于SLPS_014.90~0x62620
80128508~??: 第2脚本0.4(通常为800K),起始位置指针似乎位于SLPS_014.90~0x62620
??~??:第3脚本,村镇中的情节对话,起始位置位于第2脚本中
801FF800~801FFFFF:脚本运行时动态存取??


======== IDA分析 ================
1.打开SLPS_014.90,自动分析并内存映射
2.文件 -> 加载文件 -> 附加二进制文件, 选择MAIN/010/1.1 -> "loading offset = 0x800CDF58"
3.文件 -> 加载文件 -> 附加二进制文件, 选择SC03/001/0.4 -> "loading offset = 0x80128508"



==============0.4压缩脚本============================
压缩脚本解压后,在内存的起始位置为0x80128508
脚本中一般包含一个副字库,这个字库的位置在:文本之前的24字节~20字节,例如SC01/009/0.4的文本起始地址为0x1866a8,
则在0x186690~0x186694 -> A0DC1E80 -> 801EDCA0 -> 801EDCA0-0x80128508 -> 0xC5798, 副字库的起始位置为0xc5798


==============2.1脚本============================
未压缩,似乎是商店对话,里面的字库指针难以查找,有一种指针的查找方式如下:
进店时80127f90地址会被写入3次,第2次写入即为字库指针(在第二次内存write断点后,启用asm log查看)
该字库指针是从脚本的一个地方读取,具体位置示例见font_pointer_example.png,
规律:文本后面有一块区域包含了连续约17个内存地址,再向后数第4个内存地址,即字库指针



========控制符==================================

* 00 1字节	结束符
* 01 2字节	颜色控制符,范围0100~010E
			0100:白色字体	0101:黑色	0102:淡红	0103:粉红	0104:绿	0105:红	0106:蓝	0107:棕	0108:灰	0109:更红	010a~010e:其它各种颜色
* 02 3字节
* 03 2字节??
			好像是跳转指令,后面的1个字节不明白作用,然后在不读结束符00的情况下,跳转到下一个文本上
* 04 2字节	字幕时间轴相关,暂停一段时间,和配音同步
* 05 1字节
* 07 1字节	闪烁符号,等待输入.	
* 08 1字节	清除屏幕对话
* 09 2字节	对话框样式
			0902=普通对话框，0906=惊叹对话框, 注意:只用于对话途中动态改变对话框样式. 至于初始的对话框是什么样式,并不在文本区中,在其它地方.	
* 0A 1字节	换行. 
* 0B 4字节
* 0C 1字节??
* 0D 1字节
* 0E 1字节	动态数值,已救了多少人	
* 0F 1字节??
* 10 3字节
* 11 3字节??
* 12 4字节??
* 14 3字节
* 15 1字节
* 16 1字节??
	 	似乎会出现矩形信息框
* 17 1字节
		和选项有关,似乎是选择用的手指
* 18 1字节??
* 19 1字节
* 1E:1字节??

* 20~DF 1字节
	主字库代码,起始地址800d2ba4,在MAIN/010/1.1的4c4c处, 共192字,偏移值=(字符代码+FFE0)&0xffff
	以下2条指令为查找起始地址:
	8013928c : LUI     000000c7 (a2), 800d (32781),
	80139290 : ADDIU   800d0000 (a2), 800d0000 (a2), 2ba4 (11172),
	机器码为0d80063c a42bc624,这段指令在许多脚本中都存在
	
* Exxx 2字节
	副字库代码, E0xx~E1xx
* Fxxx 2字节
	主字库汉字代码, F0xx~F1xx, 起始地址800d3c24,在MAIN/010/1.1的5ccc处,共419字
	以下2条指令为查找起始地址:
	8013920c : LUI     00000029 (a2), 800d (32781),
	80139210 : ADDIU   800d0000 (a2), 800d0000 (a2), 3c24 (15396)
	机器码为0d80063c 243cc624,这段指令在许多脚本中都存在
	
* FFxx 2字节
	[月火水风空地日]的图形字库, 起始地址为800d6028,在MAIN/010/1.1的0x80d0处,以下2条指令为查找起始地址:
	801391ec : LUI     00000005 (a2), 800d (32781),
	801391f0 : ADDIU   800d0000 (a2), 800d0000 (a2), 6028 (24616)
	机器码为0d80063c 2860c624,这段指令在许多脚本中都存在



========压缩算法=======================================  
压缩后的二元组中:原始pos=[1,1023], 原始len=[0,63],实际最小len=2 
如果pos=0,那么len=0,代表已到达压缩文件末端


========E0字库和E8字库定位=================  
某个0.4脚本中数据如下:
80145950: 00 00 00 00 C4 00 43 8C  12 80 01 3C 28 7B 23 AC
80145960: 20 00 C2 8F 00 00 00 00  C4 00 43 8C 12 80 01 3C
80145970: 90 7F 23 AC 11 80 01 3C  48 5C 20 AC 12 80 01 3C
ASM日志如下:
80145954 : LW      00000000 (v1), 00c4 (801f35bc (v0)) [801f3680]//从801f35bc+c4=801f3680处读取,这个地址存放着第3脚本的字库指针801f5d20,载入V1
80145958 : LUI     80120000 (at), 8012 (32786),
8014595c : SW      801f5d20 (v1), 7b28 (80120000 (at)) [80127b28]//把v1存入内存,该内存地址固定用于存放E8字库,读取E8字符时取该地址做字库指针
80145960 : LW      801f35bc (v0), 0020 (801ffee8 (fp)) [801fff08]
80145964 : NOP    
80145968 : LW      801f5d20 (v1), 00c4 (801f35bc (v0)) [801f3680]
8014596c : LUI     80120000 (at), 8012 (32786),
80145970 : SW      801f5d20 (v1), 7f90 (80120000 (at)) [80127f90]//把v1存入内存,该内存地址固定用于存放E0字库,读取E0字符时取该地址做字库指针
含义:E0和E8都使用第3字库


==============对话框============================
每行最多显示17个字符
序章event的脚本位置:在ram的0x189260处
第2章城中对话:ram的0x1866b0,副文本(暂停画面中主人公的话语)在8018e4f4处,
各段语句的指针示例
8017e960 : ADDIU   80190000 (s0), 80190000 (s0), e4f4 (58612)
对应的机器码为F4 E4 10 26
E4F4=8018E4F4,为该段语句的起始位置

==========论坛讨论=======================================

http://www.romhacking.net/forum/index.php?topic=15730.20


=========表情动画==============================
表情格式:4bit,w16*h40
共9种表情动画:睁眼, 斜睁眼, 半睁眼, 闭眼, 说话,惊恐,斜半睁眼,wakeup,dead,
模式1:睁眼>半睁眼>闭眼
模式2:斜睁眼>斜半睁眼>闭眼
要去掉的表情:斜睁眼,半睁眼,斜半睁眼,wakeup,dead

前7组动画集的格式:从800D7FD4,32B(??)+1280B(图像)+12B(作用不明,其它程序引用此动画时,指针即该处地址)+4B(指向32B的地址)+12B(??)+4B(指向1280B图像的地址)+16B(结束符)
入口地址分别为:800D84F4,800D8A44,800D8F94,800D94E4,800D9A34,800D9F84,800DA4D4
后2组动画集的格式:28B(??)+1280B(图像)+12B(作用不明,其它程序引用此动画时,指针即该处地址)+4B(指向32B的地址)+12B(??)+4B(指向1280B图像的地址)+16B(结束符)
入口地址分别为:800DAA20,800DAF6C


========= 小字库相关 ====================
已发现的字体色板:蓝:352-257,BP:352-440,金钱:352-436,?:352-429,红:352-438

(448,340)->(512,400)的显存空间似乎没有使用

小字库的uv存储：
80062874: 0-9,10个uv,每个uv占2字节
80062896: A-Z,26个uv,每个uv占2字节
800628cc: 829F~8394的uv存储位置,约168字节
80062974: 81xx's UV的基准值, 815c's uv = &800629ac = (5c-40)*2+80062974  
800629b4: 大数字UV,共22字节
小字库图片扩容设计
前96高度用来存放多色8x8小字，其余宽高为32*120，共能放下12*12个10x10字,第一行编码为800x，第二行为801x，依次类推，这样共能存放4倍576个单色汉字，另外4像素高用来存放2组色板

8140=全角空格,uv=3870
8141=半角空格,uv=3871
8142=1/4空格,uv=3872



========== TODO =======================================
*.CD增大,之后的.str被覆盖一部分,导致部分配音被破坏,
	修复方案1:移动CD文件位置,要修改CD文件表,相关指针
	修复方案2:寻找SC01-07的无用图像文件,做删减
	删减候选:SC01: 005/1.0:PLAYTOY,005/1.0:PLAYTOY,SC03/027/0.0和SC03/028/0.0都是风之卷

========切换vram表情 呵欠->睡觉=======
====DMA==== @ C4D3C
0C4D40:80 - move image (320, 440)*(40, 16) -> (512, 256)
格式: move image (fromxy)*(wh) -> (toxy)
fromxy和wh来自于
70 01 40 01 10 00 28 00
70 01 68 01 10 00 28 00  70 01 90 01 10 00 28 00
70 01 B8 01 10 00 28 00  40 01 90 01 10 00 28 00
50 01 90 01 10 00 28 00  40 01 B8 01 10 00 28 00
50 01 B8 01 10 00 28 00  
*L1=R2
*L2=R3
*L3=R4
*L4=R4
*R4=R1
R3=L2
R4=L3


======
0002=1
01a5=5
80150f00=掉入水坑伤害
80029000:->sll v0,v0,1 受伤值x2
8016ae10 : ADDU    00000001 (a0), 00000018 (v0), 00000000 (r0),	//a0=attack


==============================
通过查看相关文档，或分析一些使用BIOS字库的游戏，比如沙加，我们可以知道下面信息：
BIOS对应内存地址是BFC00000-BFC7FFFF
其实BIOS字库在BFC66000，这地应对应SJI编码8140，我们可以把BFC66000当作扩展Rom使用了。比如，把游戏字库放到BIOS的66000开始。

游戏中使用BIOS数据：可以直接对BIOS地址进行任何操作，和操作内存一样。（PSP和PS3不支持写操作）
比如直接把地址赋值给寄存器 li  a0, 0xBFC66000
或用系统API（推荐）
bios_fnt:
        li        t2,0xb0
        jr        t2
        li        t1,0x51
bios_fnt这API，可直接得到某个SJI编码的BIOS字库地址v0比如8140（此时 v0=BFC66000）或889F等
        jal        bios_fnt
        li        a0,0x8140
        move        s0,v0

后言：
PS的模拟器PCFX/ePSXe可以对BIOS地址进行写操作，也就是说，不需要外挂BIOS字库，直接在游戏里动态把字库装入到BIOS FONT区域；而PSP对BIOS地址写无效，那么我们用CMF直接动态加载BIOS FONT文件。注意：CMF加载的BIOS FONT文件，是装入到BIOS空间的66000地址，不是装入整个BIOS文件。

警告：
PS模拟器可以直接把BIOS数据DMA到显存，但如果是PSP，千万不要直接DMA到显存，会黑屏，要先把BIOS的数据COPY到内存，然后从内存DMA到显存。


=======金手指,2倍伤害============================
指令:40100200
80029000 4010
80029002 0200